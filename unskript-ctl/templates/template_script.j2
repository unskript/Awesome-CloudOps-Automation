import signal 
import sys
import os
import io
import threading
import functools
import polling2
from polling2 import poll

# Logger object
_logger = None

# Script to check mapping
_script_to_check_mapping = {}

class TimeoutException(Exception):
    pass


def timeout_handler(signum, frame):
    raise TimeoutException("Checks timed out")

def _run_function(fname):
    global w
    l_cell = False
    if fname == "last_cell":
        l_cell = True
    output = None
    success = False 
    output_buffer = io.StringIO()
    sys.stdout = output_buffer
    if l_cell is True:
        last_cell()
        output = output_buffer.getvalue()
    else:
        try:
            fn = globals().get(fname)
            if _logger:
                # Since we are using decorator for controlling the timeout, the earlier way of getting const.co_name
                # would not work because, the decorator mapping mangles the function name with the wrapper. 
                # We rely on the calling function to get the check name as a mapping (dictionary).
                chk_name = ''
                if _script_to_check_mapping:
                    chk_name = _script_to_check_mapping.get(fname)
                _logger.debug(f"Starting to execute check {fn} {chk_name}")
            
            poll(globals().get(fname), 
                            step=1, 
                            timeout={{ execution_timeout }},
                            poll_forever=False,
                            check_success= lambda v: v is not None)
            success = True
        except polling2.TimeoutException:
            # Polling timeout
            if _logger:
                _logger.debug(f"Execution completed for {fn}")
        except Exception as e:
            # If one of the action fails dump the exception on console and proceed further
            print(str(e))
            if _logger:
                _logger.debug(str(e))
    sys.stdout = sys.__stdout__
    
    return output, success

def do_run_(logger = None, script_to_check_mapping = {}):
    import sys
    from tqdm import tqdm
    global _logger 
    global _script_to_check_mapping

    output = None
    if logger:
        _logger = logger
    
    if script_to_check_mapping:
        _script_to_check_mapping = script_to_check_mapping

    if _logger:
        _logger.debug("Starting to execute {{ num_checks }} number of checks")

    for i in tqdm(range({{ num_checks + 1 }}), desc="Running", leave=True, ncols=100):
        fn = "check_" + str(i)
        if hasattr(globals().get(fn), "__call__"):
            result = _run_function(fn)
            if _logger:
                if result:
                    if isinstance(result, tuple):
                        if result[-1]:
                            _logger.debug(f"Check {fn} was successful")
                        else:
                            _logger.debug(f"Check {fn} failed")
                                    
    output, _ = _run_function('last_cell')

    # Lets dump the output in the log file so we can refer to the status of it 
    # later on
    if _logger:
        if output:
            _logger.debug(output)
        else:
            _logger.debug("No output for the checks run")

    return output

if __name__ == "__main__":
    logger = None
    script_to_check_mapping = None
    try:
        logger = sys.argv[1]
        script_to_check_mapping = sys.argv[2]
    except:
        pass 
    do_run_(logger, script_to_check_mapping)