import time
import os
from tqdm import tqdm
from concurrent.futures import ThreadPoolExecutor, as_completed


def rate_limited(num_tokens, interval):
    def decorator(func):
        def wrapper(*args, **kwargs):
            nonlocal num_tokens
            current_time = time.time()
            if num_tokens <= 0:
                time.sleep(interval - (current_time % interval))
                num_tokens = 1
            else:
                num_tokens -= 1
            return func(*args, **kwargs)
        return wrapper
    return decorator

@rate_limited(num_tokens=1, interval=60)  # Adjust interval based on your needs
def execute_check_function(check_function):
    return _run_function(check_function)

@rate_limited(num_tokens=1, interval=60)  # Adjust interval based on your needs
def execute_last_cell():
    return last_cell()

def _run_function(fn):
    import io
    import os
    import sys
    global w
    l_cell = False
    if fn == "last_cell":
        l_cell = True
    fn = fn + "()"
    output = None
    output_buffer = io.StringIO()
    sys.stdout = output_buffer
    if l_cell is True:
        last_cell()
        output = output_buffer.getvalue()
    else:
        try:
            eval(fn)
        except Exception as e:
            # If one of the action fails dump the exception on console and proceed further
            print(str(e))
    sys.stdout = sys.__stdout__
    return output

def do_run_():
    check_functions = [f"check_{i}" for i in range({{ num_checks }})]

    with ThreadPoolExecutor(max_workers=3) as executor:
        futures = {executor.submit(execute_check_function, check_function): check_function for check_function in check_functions}

        for future in tqdm(as_completed(futures), desc="Running", total=len(futures), leave=True, ncols=100):
            check_function = futures[future]
            try:
                output = future.result()
                if output:
                    print(output)
            except Exception as e:
                print(f"Error executing {check_function}: {str(e)}")

    # Execute last_cell with rate limiting
    try:
        execute_last_cell()
    except Exception as e:
        print(f"Error executing last_cell: {str(e)}")

if __name__ == "__main__":
    do_run_()
