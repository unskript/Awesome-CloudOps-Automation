import signal 
import sys
import os
import io
import polling2
from polling2 import poll

# Logger object
_logger = None

class TimeoutException(Exception):
    pass

def timeout_handler(signum, frame):
    raise TimeoutException("Checks timed out")

def _run_function(fn):
    global w
    l_cell = False
    if fn == "last_cell":
        l_cell = True
    output = None
    success = False 
    output_buffer = io.StringIO()
    sys.stdout = output_buffer
    if l_cell is True:
        last_cell()
        output = output_buffer.getvalue()
    else:
        try:
            fn = globals().get(fn)
            if _logger:
                # Since lego and lego_printer are nested within the check function
                # we can use co_consts to extract the lego_printer and strip off the 
                # _printer to get the lego function name
                chk_name = ''
                for const in fn.__code__.co_consts:
                    if isinstance(const, type(fn.__code__)):
                        if const.co_name.endswith('printer'):
                            chk_name = const.co_name.replace('_printer','')
                _logger.debug(f"Starting to execute check {fn} {chk_name}")
            fn() 
            success = True
        except Exception as e:
            # If one of the action fails dump the exception on console and proceed further
            print(str(e))
            if _logger:
                _logger.debug(str(e))
    sys.stdout = sys.__stdout__
    if _logger:
        _logger.debug(f"Completed execution of check {fn}")
    return output, success

def do_run_(logger = None):
    import sys
    from tqdm import tqdm
    global _logger 
    output = None
    if logger:
        _logger = logger

    if _logger:
        _logger.debug("Starting to execute {{ num_checks }} number of checks")

    for i in tqdm(range({{ num_checks + 1 }}), desc="Running", leave=True, ncols=100):
        fn = "check_" + str(i)
        if hasattr(globals().get(fn), "__call__"):
            try:
                result = poll(lambda: _run_function(fn), 
                                step=1, 
                                timeout={{ execution_timeout }},
                                poll_forever=False)
                if result and not result[1]:
                    print('\n. Check Did not complete')
            except polling2.TimeoutException:
                print("Timeout Reached")
                continue
            except Exception as e:
                print(f" Exception Reached {str(e)}")
                return 
    output, _ = _run_function('last_cell')

    # We need to reset alarm because if any SIGALRM was triggred in the _run_function
    # then any other operation like running info checks, or running script will also
    # be subject to the same timeout restriction. Need to reset before running them.
    signal.alarm(0)

    return output

if __name__ == "__main__":
    logger = None
    try:
        logger = sys.argv[1]
    except:
        pass 
    do_run_(logger)
